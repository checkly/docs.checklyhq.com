---
title: Node.js
head:
  title: "Instrumenting Node.js with OpenTelemetry"
metatags:
  title: "Instrumenting Node.js with OpenTelemetry"
  description: "Instrument your Node.js application with OpenTelemetry and send traces to Checkly."
weight: 31
menu:
  integrations:
    parent: "Instrumenting your code with OpenTelemetry"
beta: true
---

This guide will help you instrument your Node.js application(s) with OpenTelemetry and send traces to Checkly.
<!--more-->
## Step 1: Install the OpenTelemetry packages

Install the relevant OpenTelemetry packages:

```bash
npm install --save \
    @opentelemetry/sdk-node \
    @opentelemetry/exporter-trace-otlp-proto \
    @opentelemetry/auto-instrumentations-node \
    @opentelemetry/sdk-trace-base \
    @opentelemetry/api
```

## Step 2: Initialize the instrumentation

Create a file called `tracing.js` at the root of your project and add the following code:

```javascript
// tracing.js
const { NodeSDK } = require('@opentelemetry/sdk-node')
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-proto')
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node')
const { BatchSpanProcessor, SamplingDecision } = require('@opentelemetry/sdk-trace-base')
const { trace } = require('@opentelemetry/api')

const exporter = new OTLPTraceExporter({
  timeoutMillis: 2000,
})

const sdk = new NodeSDK({
  instrumentations: [getNodeAutoInstrumentations()],
  spanProcessors: [new BatchSpanProcessor(exporter)],
  sampler: {
    shouldSample: (context, traceId, spanName, spanKind, attributes, links) => {
      const isChecklySpan = trace.getSpan(context)?.spanContext()?.traceState?.get('checkly')
      if (isChecklySpan) {
        return { decision: SamplingDecision.RECORD_AND_SAMPLED }
      } else {
        return { decision: SamplingDecision.NOT_RECORD }
      }
    },
  },
})

sdk.start()

process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('OTel Tracing terminated'))
    .catch((error) => console.log('Error terminating OTel tracing', error))
    .finally(() => process.exit(0))
})
```

Notice the `sampler` configuration. This is a custom, **head-based sampler** that will only sample spans that are generated by Checkly by
inspecting the trace state. This way you only pay for the egress traffic generated by Checkly and not for any other traffic.

## Step 3: Start your app with the instrumentation


{{< markdownpartial "/_shared/otel-api-and-endpoint.md" >}}

Then start your app with the extra `-r` flag to load the `tracing.js` file before any other files are loaded.

```bash
node -r ./tracing.js index.js
```
ðŸŽ‰ You are done. Any interactions with your app that are triggered by a Checkly synthetic monitoring check will now generate 
traces, which are sent back to Checkly and displayed in the Checkly UI.

## Reducing noise in the auto Node.js instrumentation

We found the Node.js auto-instrumentation a bit noisy. There can be a lot of file i/o and a ton of DNS calls you might not 
be interested in. Luckily, you can easily tweak that by providing some extra options to the `getNodeAutoInstrumentations()` function.
We use the following configuration to filter out some of the noise:

```javascript
instrumentations: [getNodeAutoInstrumentations({
  '@opentelemetry/instrumentation-fs': {
    enabled: false,
  },
  '@opentelemetry/instrumentation-net': {
    enabled: false,
  },
  '@opentelemetry/instrumentation-dns': {
    enabled: false,
  },
  '@opentelemetry/instrumentation-http': {
    enabled: true,
  },
})]
```
